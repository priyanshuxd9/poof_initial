
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Global helper functions
    function isAuthenticated() {
      return request.auth != null && request.auth.uid != null;
    }

    function isUser(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Helper function to check if a user is the owner of a document
    // docData would be resource.data or request.resource.data
    function isOwner(docData) {
      return isAuthenticated() && request.auth.uid == docData.ownerId;
    }

    // Helper: Is the user a member of the provided list?
    // This function is general and can be global if memberList and userId are passed.
    function isUserInMemberList(memberList, userId) {
      // CRITICAL FIX: Use hasAny for lists
      return memberList.hasAny([userId]);
    }

    // Helper function to check required fields for group creation
    function requiredGroupCreationFieldsPresent(data) {
      return data.name != null &&
             data.description != null &&
             data.inviteCode != null &&
             data.ownerId != null &&
             data.memberUserIds != null && data.memberUserIds.size() > 0 && // Ensure owner is in memberUserIds
             data.createdAt != null && // serverTimestamp() handles this
             data.selfDestructAt != null &&
             data.memberUserIds[0] == data.ownerId; // Ensure the first member is the owner
    }

    // Helper: Only specific fields are allowed during group creation
    function onlyAllowedGroupCreationFieldsWritten(data) {
      let allowedFields = ['name', 'description', 'purpose', 'theme', 'inviteCode', 'ownerId', 'memberUserIds', 'createdAt', 'selfDestructAt', 'imageUrl', 'lastActivity'];
      return data.keys().hasOnly(allowedFields);
    }

    // Helper: All expected fields are present and allowed
    function allGroupCreationFieldsPresentAndAllowed(data) {
        return requiredGroupCreationFieldsPresent(data) && onlyAllowedGroupCreationFieldsWritten(data);
    }

    // Helper: Is the group active (not yet self-destructed)?
    // This needs groupData (e.g. resource.data), so it's best used within the group match or passed data.
    function groupIsActive(groupData) {
      return groupData.selfDestructAt != null && request.time < groupData.selfDestructAt;
    }

    match /users/{userId} {
      allow read: if isUser(userId);
      allow create: if isAuthenticated() &&
                      request.resource.data.uid == request.auth.uid &&
                      request.resource.data.email == request.auth.token.email &&
                      request.resource.data.username != null &&
                      request.resource.data.username.size() >= 3 &&
                      request.resource.data.username.size() <= 20 &&
                      request.resource.data.keys().hasAll(['uid', 'email', 'username', 'photoURL', 'createdAt']) &&
                      request.resource.data.keys().size() == 5; // Ensure no extra fields
      allow update: if isUser(userId) &&
                       request.resource.data.uid == userId && // UID cannot change
                       request.resource.data.email == resource.data.email && // Email cannot change
                       request.resource.data.username == resource.data.username && // Username cannot change (for now)
                       request.resource.data.createdAt == resource.data.createdAt; // CreatedAt cannot change
                       // Allow photoURL to be updated
    }

    match /usernames/{username} {
      allow read: if isAuthenticated(); // Or more specific if needed
      allow create: if isAuthenticated() &&
                      request.resource.data.uid == request.auth.uid &&
                      request.resource.data.username == username; // Ensure username matches document ID (lowercase)
    }

    match /groups/{groupId} {
      // Helper: Is the group data valid for update by a new member joining?
      function isValidMemberJoinUpdate(currentData, newData, newMemberId) {
        return newData.memberUserIds.size() == currentData.memberUserIds.size() + 1 &&
               newData.memberUserIds.hasAll(currentData.memberUserIds) && // All old members are still there
               newData.memberUserIds.hasAny([newMemberId]) && // New member is added
               newData.lastActivity == request.time && // lastActivity is updated
               // Ensure no other fields are changed besides memberUserIds and lastActivity
               newData.name == currentData.name &&
               newData.description == currentData.description &&
               newData.purpose == currentData.purpose &&
               newData.theme == currentData.theme &&
               newData.inviteCode == currentData.inviteCode &&
               newData.ownerId == currentData.ownerId &&
               newData.createdAt == currentData.createdAt &&
               newData.selfDestructAt == currentData.selfDestructAt &&
               newData.imageUrl == currentData.imageUrl;
      }

      allow read: if isAuthenticated() &&
                     groupIsActive(resource.data) &&
                     isUserInMemberList(resource.data.memberUserIds, request.auth.uid); // Uses corrected helper

      allow create: if isAuthenticated() &&
                       allGroupCreationFieldsPresentAndAllowed(request.resource.data) &&
                       isOwner(request.resource.data) && // Check owner based on incoming data
                       request.resource.data.memberUserIds.hasAny([request.auth.uid]); // Creator must be a member


      allow update: if isAuthenticated() &&
                       groupIsActive(resource.data) && // Group must be active to be updated
                       // Scenario: New member joining via invite code
                       (
                         !isUserInMemberList(resource.data.memberUserIds, request.auth.uid) && // User is NOT already a member (uses corrected helper)
                         isValidMemberJoinUpdate(resource.data, request.resource.data, request.auth.uid)
                       );
                       // Add other update scenarios like owner changing description if needed, e.g.:
                       // || (isOwner(resource.data) && /* specific field change checks */ )

      // No delete rule for now, groups "poof" by becoming unreadable/unwritable after selfDestructAt
    }
  }
}
