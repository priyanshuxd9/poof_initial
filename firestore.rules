
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
  
    // Helper function to check if a user is a member of a group.
    function isGroupMember(groupId) {
      return get(/databases/$(database)/documents/groups/$(groupId)).data.memberUserIds.has(request.auth.uid);
    }
    
    // Helper function to check if a user can write to a group (is a member).
    // This is useful for securing sub-collections like messages.
    function canWriteToGroup(groupId) {
      let group = get(/databases/$(database)/documents/groups/$(groupId));
      // Ensure the group exists and the user is a member.
      return group.exists == true && request.auth.uid in group.data.memberUserIds;
    }
    
    // Helper function to check if a user is the owner of a group.
    function isGroupOwner(groupId) {
      return get(/databases/$(database)/documents/groups/$(groupId)).data.ownerId == request.auth.uid;
    }

    // Rules for the 'users' collection
    match /users/{userId} {
      // Any authenticated user can create their own user document.
      allow create: if request.auth != null && request.auth.uid == userId;
      // Only the authenticated user can read or update their own document.
      allow read, update: if request.auth != null && request.auth.uid == userId;
      // Users can delete their own documents.
      allow delete: if request.auth != null && request.auth.uid == userId;
    }

    // Rules for the 'usernames' collection
    match /usernames/{username} {
      // Any authenticated user can create a new username document.
      // Uniqueness is handled in backend logic with a transaction/batch.
      allow create: if request.auth != null;
      // No one can read a list of all usernames.
      allow list: if false;
      // Anyone can check if a specific username document exists.
      allow get: if true;
      // Only the associated user can delete their username document.
      allow delete: if request.auth != null && resource.data.uid == request.auth.uid;
       // No one can update a username document directly.
      allow update: if false;
    }
    
    // Rules for the 'groups' collection
    match /groups/{groupId} {
      // READ: A user can read a group's document if they are in the memberUserIds list.
      allow read: if isGroupMember(groupId);
      
      // CREATE: An authenticated user can create a group.
      // The request must include the creator's UID in the memberUserIds list and as the owner.
      allow create: if request.auth != null
                    && request.resource.data.ownerId == request.auth.uid
                    && request.auth.uid in request.resource.data.memberUserIds;

      // UPDATE: A user can update a group if they are a member.
      // However, we apply different rules for different fields.
      allow update: if isGroupMember(groupId)
      							// Members can update lastActivity or add themselves to memberUserIds (joining a group)
                      && (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastActivity', 'memberUserIds']))
                    || (isGroupOwner(groupId) // Owner can update name, description, and imageUrl
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['name', 'description', 'imageUrl']));

      // DELETE: No one can delete a group directly. Deletion is handled by a server-side function (or manually).
      allow delete: if false;

			// Rules for the 'messages' subcollection within a group
      match /messages/{messageId} {
        // READ: Members of the group can read messages.
        allow read: if canWriteToGroup(groupId);
        // CREATE: Members of the group can create messages.
        allow create: if canWriteToGroup(groupId);
        // UPDATE: Members can update a message, but ONLY the 'reactions' field.
        allow update: if canWriteToGroup(groupId)
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions']);
        // DELETE: No one can delete messages directly.
        allow delete: if false;
      }
    }
  }
}
