
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isUser(userId) {
      return request.auth.uid == userId;
    }
    
    // Usernames: Publicly readable to check for uniqueness, but only the user can create their own username document.
    match /usernames/{username} {
      allow read;
      allow create: if isAuthenticated() && request.resource.data.uid == request.auth.uid && request.resource.data.username == username;
      allow update, delete: if false; 
    }

    // User Profiles: Only the authenticated user can read or write to their own document.
    match /users/{userId} {
      allow read, write: if isUser(userId);
    }

    // Groups:
    match /groups/{groupId} {
      
      function isGroupMember() {
        return request.auth.uid in resource.data.memberUserIds;
      }
      
      // Read rule: Allow if user is authenticated and their UID is in the memberUserIds list.
      // We will also enforce the selfDestructAt check in the client query, so the rule just needs to check membership.
      allow read: if isAuthenticated() && isGroupMember();

      // Create rule: Any authenticated user can create a group.
      allow create: if isAuthenticated();

      // Update rule: Allow if an authenticated user is joining (their UID is being added to memberUserIds)
      // AND the group has not expired.
      allow update: if isAuthenticated()
                      && request.auth.uid in request.resource.data.memberUserIds   // The user must be adding themself
                      && !(request.auth.uid in resource.data.memberUserIds)      // and not already be a member
                      && request.resource.data.selfDestructAt > request.time;     // and the group must not be expired.

      // Delete rule: No one can delete a group directly. This will be handled by a backend function later.
      allow delete: if false;
    }
  }
}
