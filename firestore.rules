
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }

    // Checks if the requesting user is the owner of a given resource (based on a userIdField in the resource.data)
    function isResourceOwner(userIdField) {
      return request.auth.uid == resource.data[userIdField];
    }

    // Checks if the current authenticated user's ID matches the given userId (typically for profile operations)
    function isRequestingOwnProfile(userId) {
      return request.auth.uid == userId;
    }

    // Checks if only specified fields are being changed during an update, and no fields are removed.
    function onlyTheseFieldsAreChanged(allowedFields) {
      // Get keys of fields that are present in new data but different or not in old data
      let changedOrAddedKeys = (request.resource.data - resource.data).keys();
      // Get keys of fields that were in old data but not in new data (removed)
      let removedKeys = (resource.data - request.resource.data).keys();

      // Ensure no fields were removed
      return removedKeys.size() == 0 &&
             // Ensure changed/added keys are only from the allowed set
             changedOrAddedKeys.hasOnly(allowedFields);
    }

    // Checks if the requesting user is already a member of the group (using existing document data)
    function isAlreadyMember() {
      // Ensure memberUserIds exists and is a list before checking
      return resource.data.memberUserIds is list && request.auth.uid in resource.data.memberUserIds;
    }

    // Checks if the user being added is the one making the request
    function isAddingSelfAsNewMember() {
      return request.resource.data.memberUserIds.hasAll(resource.data.memberUserIds) &&
             request.resource.data.memberUserIds.hasAny([request.auth.uid]) &&
             request.resource.data.memberUserIds.size() == resource.data.memberUserIds.size() + 1;
    }

    function selfDestructNotPassed() {
      // Ensure selfDestructAt exists and is a timestamp before comparing
      return resource.data.selfDestructAt is timestamp && resource.data.selfDestructAt > request.time;
    }

    function requestSelfDestructNotPassed() {
      // Ensure selfDestructAt exists and is a timestamp before comparing
      return request.resource.data.selfDestructAt is timestamp && request.resource.data.selfDestructAt > request.time;
    }
    
    function isUsernameLowerCase(username) {
      return username == username.lower();
    }

    // Collection: users
    match /users/{userId} {
      allow read: if isAuthenticated() && isRequestingOwnProfile(userId);
      allow create: if request.auth.uid == userId &&
                       request.resource.data.keys().hasOnly(['uid', 'email', 'username', 'photoURL', 'createdAt']) &&
                       request.resource.data.uid == userId &&
                       request.resource.data.username.size() > 0 &&
                       request.resource.data.createdAt == request.time;
      allow update: if isAuthenticated() && isRequestingOwnProfile(userId) &&
                       onlyTheseFieldsAreChanged(['username', 'photoURL']);
    }

    // Collection: usernames
    match /usernames/{username} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() &&
                       request.auth.uid == request.resource.data.uid &&
                       request.resource.data.username == username &&
                       request.resource.data.keys().hasOnly(['uid', 'username']) &&
                       isUsernameLowerCase(username);
    }

    // Collection: groups
    match /groups/{groupId} {
      allow read: if isAuthenticated() && request.auth.uid in resource.data.memberUserIds;

      allow create: if isAuthenticated() &&
                       request.resource.data.ownerId == request.auth.uid &&
                       request.resource.data.memberUserIds == [request.auth.uid] &&
                       request.resource.data.name.size() > 0 &&
                       request.resource.data.inviteCode.size() > 0 &&
                       requestSelfDestructNotPassed() &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.lastActivity == request.time &&
                       request.resource.data.keys().hasOnly([
                         'name', 'description', 'purpose', 'theme', 'inviteCode',
                         'ownerId', 'memberUserIds', 'createdAt', 'selfDestructAt',
                         'imageUrl', 'lastActivity'
                       ]);

      allow update: if isAuthenticated() &&
                       // Scenario 1: Joining a group
                       (
                         !isAlreadyMember() && // User is not currently a member
                         isAddingSelfAsNewMember() && // User is adding themselves
                         onlyTheseFieldsAreChanged(['memberUserIds', 'lastActivity']) &&
                         request.resource.data.lastActivity == request.time &&
                         selfDestructNotPassed() // Group has not expired
                       ) ||
                       // Scenario 2: Any member posting a message (updates lastActivity)
                       (
                         isAlreadyMember() && // User is a member
                         onlyTheseFieldsAreChanged(['lastActivity']) && 
                         request.resource.data.lastActivity == request.time &&
                         selfDestructNotPassed() // Group has not expired (important for updates too)
                       );
    }
  }
}
