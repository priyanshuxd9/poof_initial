rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Usernames must be unique and can only be managed by the owner.
    match /usernames/{username} {
      allow read: if request.auth != null;
      allow create: if request.auth.uid == request.resource.data.uid
                     && request.resource.data.username == username;
      allow delete: if get(/databases/$(database)/documents/users/$(request.auth.uid)).data.username == username;
    }

    // Users can only read/write their own profile.
    match /users/{userId} {
      allow read: if request.auth != null;
      allow create: if request.auth.uid == userId;
      allow update: if request.auth.uid == userId;
      allow delete: if request.auth.uid == userId;
    }

    match /groups/{groupId} {
      // Any authenticated user can read basic group data to find groups by invite code or list their own.
      // Message subcollection access is controlled separately.
      allow read: if request.auth != null;

      // Only the owner can delete the group.
      allow delete: if resource.data.ownerId == request.auth.uid;

      // Allow group creation for any authenticated user, ensuring they are the owner and first member.
      allow create: if request.auth.uid != null
                    && request.auth.uid in request.resource.data.memberUserIds
                    && request.resource.data.ownerId == request.auth.uid;

      // Allow updates under specific conditions.
      allow update: if request.auth != null && (
        // Case 1: A new user is joining the group.
        // - Must not be a member already.
        // - Must be adding themselves to `memberUserIds`.
        // - Can only change `memberUserIds` and `lastActivity`.
        (
          !(request.auth.uid in resource.data.memberUserIds) &&
          request.resource.data.memberUserIds.size() == resource.data.memberUserIds.size() + 1 &&
          request.auth.uid in request.resource.data.memberUserIds &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['memberUserIds', 'lastActivity'])
        ) ||
        // Case 2: The owner is editing group details.
        // - Can only update specific, non-critical fields.
        (
          resource.data.ownerId == request.auth.uid &&
          request.resource.data.diff(resource.data).affectedKeys().isSubset(['name', 'description', 'imageUrl', 'purpose', 'theme', 'lastActivity'].toSet())
        ) ||
        // Case 3: A member is sending a message (which only updates `lastActivity`).
        (
          request.auth.uid in resource.data.memberUserIds &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastActivity'])
        )
      );

      // Messages subcollection
      match /messages/{messageId} {
        // Only members of the group can read messages.
        allow list, read: if request.auth != null
                          && request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.memberUserIds;

        // Any member can create a message, but must be the sender.
        allow create: if request.auth != null
                      && request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.memberUserIds
                      && request.resource.data.senderId == request.auth.uid;

        // Any member can update message reactions.
        allow update: if request.auth != null
                      && request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.memberUserIds
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions']);

        // Deleting messages is not permitted.
        allow delete: if false;
      }
    }
  }
}
