
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Usernames must be unique.
    match /usernames/{username} {
      allow read;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.uid;
      allow update: if false; // Handled by batch writes
      allow delete: if request.auth != null && request.auth.uid == resource.data.uid;
    }

    // Users can only read/update their own profile.
    match /users/{userId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.auth.uid == userId;
      allow update: if request.auth != null && request.auth.uid == userId;
      allow delete: if request.auth != null && request.auth.uid == userId;
    }

    match /groups/{groupId} {
      // Any member can read group data (for dashboard, info page, archive page).
      allow read: if request.auth.uid in resource.data.memberUserIds;

      // Creating a new group.
      allow create: if request.auth.uid == request.resource.data.ownerId
                    && request.auth.uid in request.resource.data.memberUserIds
                    && request.resource.data.memberUserIds.size() == 1;

      // Updating a group has several valid cases.
      allow update: if
        // Case 1: Joining a group with a valid invite code.
        (
            request.resource.data.memberUserIds == resource.data.memberUserIds.concat([request.auth.uid]) &&
            request.resource.data.inviteCode == resource.data.inviteCode &&
            resource.data.selfDestructAt > request.time
        ) ||
        // Case 2: Group owner updating the icon URL.
        (
            request.auth.uid == resource.data.ownerId &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['imageUrl', 'lastActivity'])
        ) ||
        // Case 3: A member updating last activity (e.g., sending a message).
        (
            request.auth.uid in resource.data.memberUserIds &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastActivity'])
        ) ||
        // Case 4: Cleanup process for an expired group.
        (
            resource.data.selfDestructAt <= request.time &&
            request.resource.data.isCleaned == true &&
            request.resource.data.inviteCode == null
        );

      allow delete: if false;

      match /messages/{messageId} {
        // Allow members to read/write messages ONLY if the group has NOT expired.
        allow list, get: if request.auth.uid in get(/databases/(default)/documents/groups/$(groupId)).data.memberUserIds
                        && get(/databases/(default)/documents/groups/$(groupId)).data.selfDestructAt > request.time;
                        
        allow create: if request.auth.uid == request.resource.data.senderId
                      && request.auth.uid in get(/databases/(default)/documents/groups/$(groupId)).data.memberUserIds
                      && get(/databases/(default)/documents/groups/$(groupId)).data.selfDestructAt > request.time;
        
        // Allow members to update messages (for reactions) if group has not expired
        allow update: if request.auth.uid in get(/databases/(default)/documents/groups/$(groupId)).data.memberUserIds
                      && get(/databases/(default)/documents/groups/$(groupId)).data.selfDestructAt > request.time;

        // Allow messages to be deleted ONLY if the group IS expired (by the cleanup process).
        allow delete: if get(/databases/(default)/documents/groups/$(groupId)).data.selfDestructAt <= request.time;
      }
    }
  }
}
