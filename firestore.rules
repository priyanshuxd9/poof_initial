rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Users collection:
    // - Anyone can read a user's public profile.
    // - Only the authenticated user can create or update their own profile.
    match /users/{userId} {
      allow read: if true;
      allow create, update: if request.auth != null && request.auth.uid == userId;
      // Deletion is handled by a backend function which has admin privileges,
      // so no direct client delete rule is needed.
      allow delete: if false; 
    }

    // Usernames collection:
    // - Used to enforce username uniqueness.
    // - Reading a specific username doc is allowed to check for existence.
    // - Creation and deletion are only allowed if consistent with a user profile update.
    match /usernames/{username} {
      allow read: if true;
      // Creation/deletion tied to user creation/update in application logic (batched writes).
      // No direct open write access.
      allow write: if false; 
    }

    // Groups collection:
    match /groups/{groupId} {
      // Allow read access only to members of the group.
      allow read: if request.auth.uid in resource.data.memberUserIds;
      
      // Creating a new group: The creator must be the owner and first member.
      allow create: if request.auth.uid == request.resource.data.ownerId &&
                       request.auth.uid in request.resource.data.memberUserIds &&
                       request.resource.data.memberUserIds.size() == 1;

      // Updating a group:
      // - Joining: A user can add themselves to the members list. App logic validates invite code.
      // - Updating info (icon): The owner can update the imageUrl.
      // - Other updates (e.g., lastActivity): Any member can update.
      // - Cleanup: The app can mark the group as cleaned.
      allow update: if request.auth.uid != null && (
        // Case 1: Joining a group (only self-addition is allowed)
        (request.resource.data.memberUserIds == resource.data.memberUserIds.append(request.auth.uid)) ||
        // Case 2: Owner updating group icon
        (request.resource.data.imageUrl != resource.data.imageUrl && request.auth.uid == resource.data.ownerId) ||
        // Case 3: Any member updating last activity
        (request.resource.data.lastActivity != resource.data.lastActivity && request.auth.uid in resource.data.memberUserIds) ||
        // Case 4: Background cleanup process marking group as cleaned.
        (request.resource.data.isCleaned == true && resource.data.isCleaned == false)
      );

      // Deleting a group: Not allowed from the client. Cleanup is handled by app logic.
      allow delete: if false;

      // Messages subcollection:
      match /messages/{messageId} {
        // Any group member can read messages.
        allow read: if request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.memberUserIds;
        
        // Creating messages: Only group members can create messages.
        allow create: if request.auth.uid == request.resource.data.senderId &&
                       request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.memberUserIds;

        // Updating messages (for reactions): Only group members can update.
        allow update: if request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.memberUserIds;

        // Deleting messages: Only allowed if the group's self-destruct timer has passed.
        // This rule supports the "cleanup-on-visit" functionality.
        allow delete: if request.time > get(/databases/$(database)/documents/groups/$(groupId)).data.selfDestructAt;
      }
    }
  }
}
