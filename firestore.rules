rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ========== HELPER FUNCTIONS ==========
    function isSignedIn() {
      return request.auth != null;
    }

    function isMember(groupData) {
      return request.auth.uid in groupData.memberUserIds;
    }

    // ========== USERNAMES (for ensuring uniqueness) ==========
    match /usernames/{username} {
      allow read: if isSignedIn();
      // A user can only create a username document that maps to their own UID
      allow create: if isSignedIn() && request.resource.data.uid == request.auth.uid;
      // A user can only delete their own username document
      allow delete: if isSignedIn() && resource.data.uid == request.auth.uid;
      allow update: if false; // Usernames are not updatable, they are deleted and re-created
    }

    // ========== USERS (profile data) ==========
    match /users/{userId} {
      allow read: if isSignedIn();
      // This rule allows a user to create their own profile document.
      // It's intentionally simple to avoid race conditions during sign-up.
      allow create: if request.auth.uid == userId;
      // A user can only update their own profile (username or photo)
      allow update: if request.auth.uid == userId
                    && request.resource.data.uid == userId; // Cannot change UID
    }

    // ========== GROUPS & MESSAGES ==========
    match /groups/{groupId} {
      // READ: Any signed-in user can read group metadata. Messages are protected by a separate rule.
      allow read: if isSignedIn();

      // CREATE: A user can create a group if they are the owner and sole initial member.
      allow create: if isSignedIn()
                    && request.resource.data.ownerId == request.auth.uid
                    && request.resource.data.memberUserIds[0] == request.auth.uid
                    && request.resource.data.memberUserIds.size() == 1;

      // UPDATE: A user can update a group under specific conditions (joining, leaving, owner editing, etc.)
      allow update: if isSignedIn() && (
                      isJoiningGroup(resource.data, request.resource.data) ||
                      isLeavingGroup(resource.data, request.resource.data) ||
                      isOwnerManagingGroup(resource.data, request.resource.data) ||
                      isMemberUpdatingActivity(resource.data, request.resource.data)
                    );
      
      // DELETE: Groups are never deleted by clients.
      allow delete: if false;

      // --- HELPER FUNCTIONS for /groups/{groupId} ---

      function isJoiningGroup(existing, incoming) {
        let isAddingSelf = incoming.memberUserIds == existing.memberUserIds.concat([request.auth.uid]);
        let isNotAlreadyMember = !isMember(existing);
        let onlyMembersAndActivityChanged = incoming.diff(existing).affectedKeys().hasOnly(['memberUserIds', 'lastActivity']);
        
        return isAddingSelf && isNotAlreadyMember && onlyMembersAndActivityChanged;
      }
      
      function isLeavingGroup(existing, incoming) {
          let isRemovingSelf = incoming.memberUserIds == existing.memberUserIds.remove([request.auth.uid]);
          let isNotOwner = existing.ownerId != request.auth.uid;
          let isExistingMember = isMember(existing);
          let onlyMembersAndActivityChanged = incoming.diff(existing).affectedKeys().hasOnly(['memberUserIds', 'lastActivity']);

          return isRemovingSelf && isNotOwner && isExistingMember && onlyMembersAndActivityChanged;
      }

      function isOwnerManagingGroup(existing, incoming) {
        let userIsOwner = existing.ownerId == request.auth.uid;
        let immutableFieldsUnchanged = incoming.ownerId == existing.ownerId
                                       && incoming.createdAt == existing.createdAt
                                       && incoming.inviteCode == existing.inviteCode
                                       && incoming.memberUserIds == existing.memberUserIds;

        return userIsOwner && immutableFieldsUnchanged;
      }
      
      function isMemberUpdatingActivity(existing, incoming) {
        let userIsMember = isMember(existing);
        let onlyActivityChanges = incoming.diff(existing).affectedKeys().hasOnly(['lastActivity']);
        
        return userIsMember && onlyActivityChanges;
      }

      // === SUBCOLLECTION: MESSAGES ===
      match /messages/{messageId} {
        // READ: Only members of the parent group can read messages.
        allow read: if isSignedIn() && isMember(get(/databases/$(database)/documents/groups/$(groupId)).data);

        // CREATE: Only members can create messages, and they must be the sender.
        allow create: if isSignedIn()
                      && isMember(get(/databases/$(database)/documents/groups/$(groupId)).data)
                      && request.resource.data.senderId == request.auth.uid;

        // UPDATE: Only members can update messages, and ONLY for adding/removing reactions.
        allow update: if isSignedIn()
                      && isMember(get(/databases/$(database)/documents/groups/$(groupId)).data)
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions']);
        
        // DELETE: No one can delete individual messages.
        allow delete: if false;
      }
    }
  }
}
