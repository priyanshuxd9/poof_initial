
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // HELPER FUNCTIONS
    function isAuth() {
      return request.auth != null;
    }
    
    function isOwner(groupId) {
      return request.auth.uid == get(/databases/$(database)/documents/groups/$(groupId)).data.ownerId;
    }
    
    function isMember(groupId) {
      return request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.memberUserIds;
    }
    
    // Check if the only fields being changed are in a given list
    function fieldsAre(list) {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(list);
    }

    // Check if immutable fields that should never change are, in fact, unchanged
    function coreGroupFieldsUnchanged() {
      return request.resource.data.ownerId == resource.data.ownerId &&
             request.resource.data.createdAt == resource.data.createdAt;
    }

    // RULES FOR /usernames
    match /usernames/{username} {
      allow read: if isAuth();
      allow create: if isAuth() && request.resource.data.uid == request.auth.uid;
      // Username updates are handled by a batched write (delete old, create new) in a transaction
      allow update: if false; 
      allow delete: if isAuth() && resource.data.uid == request.auth.uid;
    }

    // RULES FOR /users
    match /users/{userId} {
      allow read: if isAuth();
      allow create: if request.auth.uid == userId;
      // Allow username or photoURL to be updated, but nothing else.
      allow update: if request.auth.uid == userId
                      && request.resource.data.uid == resource.data.uid
                      && request.resource.data.email == resource.data.email
                      && request.resource.data.createdAt == resource.data.createdAt;
      allow delete: if request.auth.uid == userId;
    }

    // RULES FOR /groups
    match /groups/{groupId} {
      allow read: if isMember(groupId);

      // Only authenticated users can create groups they own and are a member of
      allow create: if isAuth() 
                    && request.auth.uid == request.resource.data.ownerId
                    && request.auth.uid in request.resource.data.memberUserIds;

      // Complex update logic, broken down into secure cases
      allow update: if isAuth() && coreGroupFieldsUnchanged() && (
        // Case 1: Owner updating group icon
        ( isOwner(groupId) && fieldsAre(['imageUrl']) ) ||
        // Case 2: Owner updating the self-destruct timer
        ( isOwner(groupId) && fieldsAre(['selfDestructAt']) ) ||
        // Case 3: Any member sending a message (updates lastActivity)
        ( isMember(groupId) && fieldsAre(['lastActivity']) ) ||
        // Case 4: A non-member joining the group
        ( !isMember(groupId) && 
          request.resource.data.memberUserIds == resource.data.memberUserIds.concat([request.auth.uid]) &&
          fieldsAre(['memberUserIds', 'lastActivity'])
        ) ||
        // Case 5: Any member of an expired group can trigger cleanup
        ( isMember(groupId) &&
          resource.data.selfDestructAt < request.time &&
          fieldsAre(['isCleaned', 'inviteCode'])
        )
      );

      // Nobody can delete a group document directly. Cleanup is handled by marking as cleaned.
      allow delete: if false;
      
      // RULES for messages subcollection
      match /messages/{messageId} {
        allow read, create: if isMember(groupId);
        // Allow members to update reactions on a message
        allow update: if isMember(groupId) && fieldsAre(['reactions']);
        // Only allow deleting messages when the group is expired and being cleaned.
        allow delete: if isMember(groupId) && get(/databases/$(database)/documents/groups/$(groupId)).data.selfDestructAt < request.time;
      }
    }
  }
}
