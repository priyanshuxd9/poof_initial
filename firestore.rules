
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isGroupMember(groupId) {
      // Check if the user's ID is in the member list of the specified group.
      return isSignedIn() && get(/databases/$(database)/documents/groups/$(groupId)).data.memberUserIds.hasAny([request.auth.uid]);
    }

    function isGroupOwner(groupId) {
      // Check if the user is the owner of the specified group.
      return isSignedIn() && get(/databases/$(database)/documents/groups/$(groupId)).data.ownerId == request.auth.uid;
    }

    // Usernames: Publicly readable for checks, but only the user can own their username doc.
    match /usernames/{username} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.uid == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.uid == request.auth.uid;
    }

    // Users: Publicly readable for profile info, but only the user can modify their own doc.
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isUser(userId);
      allow update: if isUser(userId);
      allow delete: if isUser(userId);
    }

    // Groups: Complex rules for creation, joining, and member-only access.
    match /groups/{groupId} {
      // READ: Any member of the group can read its data.
      // This rule also implicitly secures dashboard list queries.
      allow read: if isGroupMember(groupId);

      // CREATE: A user must be signed in, be the owner, and be the first member.
      allow create: if isSignedIn()
                    && request.resource.data.ownerId == request.auth.uid
                    && request.resource.data.memberUserIds[0] == request.auth.uid
                    && request.resource.data.memberUserIds.size() == 1;

      // UPDATE: Allow updates under specific conditions (joining, owner updates, activity updates).
      allow update: if isSignedIn() && (
        // Condition 1: Joining the group
        (
            resource.data.memberUserIds.hasAny([request.auth.uid]) == false
            && request.resource.data.memberUserIds.hasAll([request.auth.uid]) == true
            && request.resource.data.memberUserIds.size() == resource.data.memberUserIds.size() + 1
            && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['memberUserIds', 'lastActivity'])
        ) ||
        // Condition 2: Owner updating group icon
        (
            isGroupOwner(groupId)
            && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['imageUrl'])
        ) ||
        // Condition 3: Member updating last activity (e.g., when sending a message)
        (
            isGroupMember(groupId)
            && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastActivity'])
        )
      );
      
      // DELETE: No client-side deletes allowed. Groups self-destruct.
      allow delete: if false;

      // Messages Subcollection
      match /messages/{messageId} {
        // READ/CREATE: Only group members can read or create messages.
        allow list: if isGroupMember(groupId);
        allow get: if isGroupMember(groupId);
        
        allow create: if isGroupMember(groupId)
                       && request.resource.data.senderId == request.auth.uid;

        // UPDATE: Members can update reactions.
        allow update: if isGroupMember(groupId) 
                       && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions']);
                       
        // DELETE: No client-side deletes.
        allow delete: if false;
      }
    }
  }
}
