
rules_version = '2';

service cloud.firestore {

  // Global helper functions (do not use 'resource' or 'request.resource')
  function isAuthenticated() {
    return request.auth != null;
  }

  function isUser(userId) {
    return isAuthenticated() && request.auth.uid == userId;
  }

  match /databases/{database}/documents {

    // Match all documents in the 'users' collection
    match /users/{userId} {
      allow read: if isUser(userId);
      allow create: if isUser(userId) &&
                       request.resource.data.uid == userId &&
                       request.resource.data.username is string &&
                       request.resource.data.username.size() > 0 &&
                       request.resource.data.email is string;
      allow update: if isUser(userId); // Be more specific if needed (e.g., allow changing only photoURL)
      allow delete: if false; // Or isUser(userId) for self-delete
    }

    // Match all documents in the 'usernames' collection
    // Usernames are stored in lowercase to ensure uniqueness check is case-insensitive.
    match /usernames/{usernameDocId} {
      allow read: if isAuthenticated(); // Allow any authenticated user to read (for unique checks)
      allow create: if isAuthenticated() &&
                       request.resource.data.uid == request.auth.uid &&
                       request.resource.data.username == usernameDocId && // usernameDocId is the lowercase username
                       request.resource.data.username.size() > 0;
      allow delete: if false; // Typically usernames are not deleted or only by admin/owner
    }

    // Match all documents in the 'groups' collection
    match /groups/{groupId} {

      // Group-specific helper functions
      // These can use 'resource.data' (for existing doc) or 'request.resource.data' (for incoming doc)
      function isCurrentMember() {
        return isAuthenticated() && request.auth.uid in resource.data.memberUserIds;
      }

      // Checks if the group (as it exists in DB) is still active
      function groupIsCurrentlyActive() {
        return resource.data.selfDestructAt > request.time;
      }

      // Checks if the incoming group data specifies an active self-destruct time
      function incomingGroupIsActive() {
        return request.resource.data.selfDestructAt is timestamp &&
               request.resource.data.selfDestructAt > request.time;
      }

      allow read: if isAuthenticated() && isCurrentMember();

      allow create: if isAuthenticated() &&
                       request.resource.data.ownerId == request.auth.uid &&
                       request.resource.data.memberUserIds == [request.auth.uid] &&
                       request.resource.data.name is string && request.resource.data.name.size() > 0 &&
                       request.resource.data.inviteCode is string && request.resource.data.inviteCode.size() > 0 &&
                       (request.resource.data.description is string || request.resource.data.description == null) &&
                       (request.resource.data.purpose is string || request.resource.data.purpose == null) &&
                       (request.resource.data.theme is string || request.resource.data.theme == null) &&
                       (request.resource.data.imageUrl is string || request.resource.data.imageUrl == null) &&
                       incomingGroupIsActive() &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.lastActivity == request.time &&
                       request.resource.data.keys().hasOnly([
                         'name', 'description', 'purpose', 'theme', 'inviteCode',
                         'ownerId', 'memberUserIds', 'createdAt', 'selfDestructAt',
                         'imageUrl', 'lastActivity'
                       ]);

      // This update rule is specifically for JOINING a group.
      // Other updates (e.g., changing group name by owner) would need separate conditions.
      allow update: if isAuthenticated() && groupIsCurrentlyActive() &&
                       !(request.auth.uid in resource.data.memberUserIds) && // User is NOT already a member
                       request.resource.data.memberUserIds == resource.data.memberUserIds.concat([request.auth.uid]) && // Only adding self
                       request.resource.data.lastActivity == request.time &&
                       // Ensure only 'memberUserIds' and 'lastActivity' are being changed
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['memberUserIds', 'lastActivity']) &&
                       // Ensure no other critical fields are touched if they are resent in the request
                       request.resource.data.name == resource.data.name &&
                       request.resource.data.ownerId == resource.data.ownerId &&
                       request.resource.data.inviteCode == resource.data.inviteCode &&
                       request.resource.data.createdAt == resource.data.createdAt &&
                       request.resource.data.selfDestructAt == resource.data.selfDestructAt;


      allow delete: if false; // Groups are deleted based on selfDestructAt, typically by a backend process
    }
  }
}
