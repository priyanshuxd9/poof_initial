
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ========== HELPER FUNCTIONS ==========
    function isSignedIn() {
      return request.auth != null;
    }

    function isMember(groupData) {
      // Check if the requesting user's UID is in the group's member list.
      return request.auth.uid in groupData.memberUserIds;
    }

    function isOwner(groupData) {
      // Check if the requesting user is the owner of the group.
      return groupData.ownerId == request.auth.uid;
    }

    // ========== USERNAMES (for ensuring uniqueness) ==========
    match /usernames/{username} {
      allow read: if isSignedIn();
      // A user can only create a username document that maps to their own UID
      allow create: if isSignedIn() && request.resource.data.uid == request.auth.uid;
      // A user can only delete their own username document
      allow delete: if isSignedIn() && resource.data.uid == request.auth.uid;
      allow update: if false; // Usernames are not updatable, they are deleted and re-created
    }

    // ========== USERS (profile data) ==========
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.auth.uid == userId;
      // A user can only update their own profile (username or photo)
      allow update: if isSignedIn() && request.auth.uid == userId
                    && request.resource.data.uid == userId; // Cannot change UID
    }

    // ========== GROUPS & MESSAGES ==========
    match /groups/{groupId} {

      // --- PERMISSIONS ---
      // Reading group data is allowed for any signed-in user. Sensitive data is in subcollections.
      allow read: if isSignedIn();
      
      allow create: if isSignedIn() && isCreatingOwnGroup(request.resource.data);

      allow update: if isSignedIn() && (
        isJoiningGroup() ||
        isOwnerUpdatingGroup() ||
        isMemberUpdatingActivity() ||
        isSystemCleaningUp()
      );

      allow delete: if false; // Groups are never deleted by clients

      // --- HELPER FUNCTIONS for /groups/{groupId} ---
      function isCreatingOwnGroup(groupData) {
        // When creating a group, the owner must be the one making the request,
        // and they must be the only member initially.
        return groupData.ownerId == request.auth.uid
          && groupData.memberUserIds == [request.auth.uid];
      }

      function isJoiningGroup() {
        let incoming = request.resource.data;
        let existing = resource.data;
        
        // A user can join if they are not already a member and they are only adding their own UID.
        let isAddingSelf = incoming.memberUserIds == existing.memberUserIds.concat([request.auth.uid]);
        let isNotAlreadyMember = !isMember(existing);

        // All other fields must remain unchanged, except for lastActivity which is also updated on join.
        let otherFieldsUnchanged = incoming.diff(existing).affectedKeys().hasOnly(['memberUserIds', 'lastActivity']);

        return isAddingSelf && isNotAlreadyMember && otherFieldsUnchanged;
      }

      function isOwnerUpdatingGroup() {
        // The owner can update the group icon URL or the self-destruct timer.
        let userIsOwner = isOwner(resource.data);

        // The only fields that can be changed in this operation are imageUrl and selfDestructAt.
        let allowedChanges = ['imageUrl', 'selfDestructAt'];
        let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
        let allChangesAllowed = changedKeys.hasOnly(allowedChanges);

        return userIsOwner && allChangesAllowed;
      }
      
      function isMemberUpdatingActivity() {
        // Any member can update the lastActivity timestamp (e.g., by sending a message).
        let userIsMember = isMember(resource.data);
        
        // The only field being changed must be lastActivity.
        let onlyActivityChanges = request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastActivity']);
        
        return userIsMember && onlyActivityChanges;
      }

      function isSystemCleaningUp() {
        // This rule allows the "cleanup" function to run on an expired group.
        // It can only be called if the group's selfDestructAt time has passed.
        let isExpired = resource.data.selfDestructAt.toMillis() < request.time.toMillis();

        // The only changes allowed are setting isCleaned to true and nullifying the inviteCode.
        let allowedChanges = ['isCleaned', 'inviteCode'];
        let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
        let allChangesAllowed = changedKeys.hasOnly(allowedChanges);

        // The new values must be correct.
        let isMarkedCleaned = request.resource.data.isCleaned == true;
        let inviteCodeNulled = request.resource.data.inviteCode == null;

        // Any member can trigger this cleanup.
        let userIsMember = isMember(resource.data);

        return userIsMember && isExpired && allChangesAllowed && isMarkedCleaned && inviteCodeNulled;
      }

      // === SUBCOLLECTION: MESSAGES ===
      match /messages/{messageId} {
        // READ: Only members of the parent group can read messages.
        allow read: if isSignedIn() && isMember(get(/databases/$(database)/documents/groups/$(groupId)).data);

        // CREATE: Only members can create messages, and they must be the sender.
        allow create: if isSignedIn()
                      && isMember(get(/databases/$(database)/documents/groups/$(groupId)).data)
                      && request.resource.data.senderId == request.auth.uid;

        // UPDATE: Only members can update messages (for reactions).
        allow update: if isSignedIn()
                      && isMember(get(/databases/$(database)/documents/groups/$(groupId)).data)
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions']);
        
        // DELETE: No one can delete individual messages. They are cleaned up with the group.
        allow delete: if false;
      }
    }
  }
}
