
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if the document being created ONLY contains keys from the allowedFields list.
    function onlyTheseFieldsAreWritten(allowedFields) {
      return request.resource.data.keys().hasOnly(allowedFields);
    }

    // Helper function to check if the write operation ONLY changes fields listed in allowedFields.
    // Other fields must remain unchanged from their existing values.
    function onlyTheseFieldsAreChanged(allowedFields) {
      let affected = request.resource.data.diff(resource.data).affectedKeys;
      return affected.hasOnly(allowedFields);
    }

    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    match /usernames/{username} {
      allow read: if request.auth != null;
      // Allow create if user is authenticated, uid matches, username matches, and only uid/username fields are written.
      allow create: if request.auth != null &&
                       request.resource.data.uid == request.auth.uid &&
                       request.resource.data.username == username && // username is the document ID (lowercase)
                       onlyTheseFieldsAreWritten(['uid', 'username']);
    }

    match /groups/{groupId} {
      allow read: if request.auth != null && request.auth.uid in resource.data.memberUserIds;

      allow create: if request.auth != null &&
                       request.auth.uid == request.resource.data.ownerId &&
                       request.auth.uid in request.resource.data.memberUserIds &&
                       request.resource.data.memberUserIds.size() == 1 && // Initially, only the owner is a member
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.lastActivity == request.time &&
                       request.resource.data.selfDestructAt is timestamp &&
                       request.resource.data.selfDestructAt > request.time && // Self-destruct must be in the future
                       request.resource.data.name is string && request.resource.data.name.size() > 0 &&
                       request.resource.data.description is string &&
                       (request.resource.data.purpose == null || request.resource.data.purpose is string) &&
                       (request.resource.data.theme == null || request.resource.data.theme is string) &&
                       request.resource.data.inviteCode is string && request.resource.data.inviteCode.size() > 0 &&
                       (request.resource.data.imageUrl == null || request.resource.data.imageUrl is string) &&
                       // Ensure only specific fields are written on create
                       onlyTheseFieldsAreWritten([
                         'name', 'description', 'purpose', 'theme', 'inviteCode',
                         'ownerId', 'memberUserIds', 'createdAt', 'selfDestructAt',
                         'imageUrl', 'lastActivity'
                       ]);

      allow update: if request.auth != null &&
                       // Scenario 1: Joining a group
                       (
                         request.auth.uid in request.resource.data.memberUserIds &&     // Current user is in the NEW member list
                         !(request.auth.uid in resource.data.memberUserIds) &&          // Current user was NOT in the OLD member list
                         request.resource.data.memberUserIds == resource.data.memberUserIds.concat([request.auth.uid]) && // The new list is exactly the old list + current user
                         request.resource.data.lastActivity == request.time &&
                         onlyTheseFieldsAreChanged(['memberUserIds', 'lastActivity']) &&  // Ensures ONLY these fields were changed from the original document
                         resource.data.selfDestructAt > request.time                    // Group has not expired (poofed)
                       );
                       // Add other update scenarios here if needed, e.g., owner updating details:
                       // || (request.auth.uid == resource.data.ownerId && /* other conditions */)

      // Allow delete by owner or if group has poofed (implement poof logic via backend function ideally)
      // allow delete: if request.auth != null && request.auth.uid == resource.data.ownerId;
    }
  }
}
