rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // =====================================================================
    // HELPER FUNCTIONS
    // =====================================================================
    function isSignedIn() {
      return request.auth != null;
    }

    // =====================================================================
    // USERNAMES (for ensuring uniqueness)
    // =====================================================================
    match /usernames/{username} {
      allow read: if isSignedIn();
      // A user can only create a username document that maps to their own UID
      allow create: if isSignedIn() && request.resource.data.uid == request.auth.uid;
      // A user can only delete their own username document
      allow delete: if isSignedIn() && resource.data.uid == request.auth.uid;
      allow update: if false; // Usernames are not updatable, they are deleted and re-created
    }

    // =====================================================================
    // USERS (profile data)
    // =====================================================================
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.auth.uid == userId;
      // A user can only update their own profile (username or photo)
      allow update: if isSignedIn()
                    && request.auth.uid == userId
                    && request.resource.data.uid == userId; // Cannot change UID
      allow delete: if isSignedIn() && request.auth.uid == userId;
    }
    
    // =====================================================================
    // GROUPS & MESSAGES
    // =====================================================================
    match /groups/{groupId} {
      // --- PERMISSIONS ---
      function isMember() {
        return request.auth.uid in resource.data.memberUserIds;
      }
      
      function isOwner() {
        return request.auth.uid == resource.data.ownerId;
      }

      // READ: A user can read a group's details if they are a member.
      allow read: if isSignedIn() && isMember();

      // CREATE: A user can create a group if they are the owner and sole initial member.
      allow create: if isSignedIn()
                    && request.resource.data.ownerId == request.auth.uid
                    && request.resource.data.memberUserIds == [request.auth.uid];
                      
      // UPDATE: A user can update a group under specific conditions (joining, owner editing, etc.).
      allow update: if isSignedIn() && (isJoiningGroup() || isOwnerEditing() || isOwnerUpdatingTimer());

      // DELETE: Groups are never deleted by clients, only by backend functions (implicitly).
      allow delete: if false;


      // --- HELPER FUNCTIONS for group updates ---
      function isJoiningGroup() {
        let incoming = request.resource.data;
        let existing = resource.data;
        
        let isAddingSelf = incoming.memberUserIds == existing.memberUserIds.concat([request.auth.uid]);
        let isNotAlreadyMember = !(request.auth.uid in existing.memberUserIds);

        // Ensure no other critical fields are being changed when joining
        return isAddingSelf && isNotAlreadyMember
          && incoming.name == existing.name
          && incoming.description == existing.description
          && incoming.ownerId == existing.ownerId;
      }

      function isOwnerEditing() {
        let incoming = request.resource.data;
        let existing = resource.data;

        // Ensure only mutable fields are being changed by the owner.
        let allowedFields = ['name', 'description', 'imageUrl', 'lastActivity'];
        let changedKeys = incoming.diff(existing).affectedKeys();
        
        return isOwner() && changedKeys.hasOnly(allowedFields);
      }

      function isOwnerUpdatingTimer() {
        let incoming = request.resource.data;
        let existing = resource.data;

        // Ensure only the selfDestructAt field is being changed by the owner.
         let allowedFields = ['selfDestructAt'];
         let changedKeys = incoming.diff(existing).affectedKeys();
         
         return isOwner() && changedKeys.hasOnly(allowedFields);
      }


      // --- SUBCOLLECTION: MESSAGES ---
      match /messages/{messageId} {
        // READ: Only members of the parent group can read messages.
        allow read: if isSignedIn() && get(/databases/$(database)/documents/groups/$(groupId)).data.memberUserIds.hasAny([request.auth.uid]);

        // CREATE: Only members can create messages, and they must be the sender.
        allow create: if isSignedIn()
                      && get(/databases/$(database)/documents/groups/$(groupId)).data.memberUserIds.hasAny([request.auth.uid])
                      && request.resource.data.senderId == request.auth.uid;

        // UPDATE: Only members can update messages (for reactions).
        // They cannot change the original text, sender, or creation time.
        allow update: if isSignedIn()
                      && get(/databases/$(database)/documents/groups/$(groupId)).data.memberUserIds.hasAny([request.auth.uid])
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions']);
        
        // DELETE: No one can delete individual messages.
        allow delete: if false;
      }
    }
  }
}
