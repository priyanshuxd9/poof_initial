
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ======== GENERAL HELPER FUNCTIONS ========
    // These functions do not depend on 'resource.data' of a specific collection
    // and can be used by any rule within this database.
    function isAuthenticated() {
      return request.auth != null;
    }

    // Checks if the currently authenticated user is the user specified by userId.
    function isUser(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Checks if the currently authenticated user is the owner, based on a provided ownerId field.
    function isOwner(ownerIdToCheck) {
      return isAuthenticated() && request.auth.uid == ownerIdToCheck;
    }

    // Checks if a string is not empty and within a max length.
    function isValidString(str, minLength, maxLength) {
      return str is string && str.size() >= minLength && str.size() <= maxLength;
    }

    // Checks if a value is a timestamp and in the future.
    function isFutureTimestamp(t) {
      return t is timestamp && t > request.time;
    }

    // Checks if a value is a server timestamp placeholder or an actual timestamp.
    function isServerTimestampOrTimestamp(t) {
      return t == request.time || t is timestamp;
    }


    // ======== USERS COLLECTION (/users/{userId}) ========
    match /users/{userId} {
      allow read: if isUser(userId);
      allow create: if isAuthenticated() &&
                       request.resource.data.uid == request.auth.uid && // Check if creating user is the one being created
                       request.resource.data.username == request.resource.data.username && // Placeholder, should be validated
                       isValidString(request.resource.data.username, 3, 20) &&
                       request.resource.data.email == request.auth.email &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.keys().hasOnly(['uid', 'username', 'email', 'createdAt', 'photoURL']); // Ensure only allowed fields
      allow update: if false;
      allow delete: if false;
    }

    // ======== USERNAMES COLLECTION (/usernames/{username}) ========
    // Stores a mapping of username.toLowerCase() to uid for uniqueness checks.
    match /usernames/{usernameDocId} { // usernameDocId is the lowercase username
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() &&
                       request.resource.data.uid == request.auth.uid &&
                       request.resource.data.username.lower() == usernameDocId && // username stored here is case-preserved
                       request.resource.data.keys().hasOnly(['uid', 'username']);
      allow update: if false;
      allow delete: if false;
    }

    // ======== GROUPS COLLECTION (/groups/{groupId}) ========
    match /groups/{groupId} {

      // --- Group-Specific Helper Functions ---
      // These helpers use 'resource.data' or 'request.resource.data' specific to a group.

      // Checks if a user is in a given member list.
      function isUserInMemberList(memberList, userIdToFind) {
        return memberList is list && userIdToFind != null && memberList.hasAny([userIdToFind]);
      }

      // Checks if the group (existing document) is still active based on its selfDestructAt time.
      function groupIsActive() {
        // Ensure resource.data.selfDestructAt exists and is a timestamp before comparing
        return 'selfDestructAt' in resource.data &&
               resource.data.selfDestructAt is timestamp &&
               resource.data.selfDestructAt > request.time;
      }

      // Validates fields for group creation.
      function hasValidGroupCreationFields() {
        let data = request.resource.data;
        return isValidString(data.name, 3, 50) &&
               isValidString(data.description, 5, 200) &&
               (data.purpose == null || isValidString(data.purpose, 0, 100)) &&
               (data.theme == null || isValidString(data.theme, 0, 50)) &&
               (data.imageUrl == null || data.imageUrl is string) &&
               data.ownerId == request.auth.uid &&
               data.memberUserIds is list && data.memberUserIds.size() == 1 && data.memberUserIds[0] == request.auth.uid &&
               isValidString(data.inviteCode, 8, 8) && // Assuming fixed length 8
               data.selfDestructTimerDays is number && data.selfDestructTimerDays >= 1 && data.selfDestructTimerDays <= 31 &&
               isFutureTimestamp(data.selfDestructAt) &&
               data.createdAt == request.time &&
               data.lastActivity == request.time;
      }
      
      function allGroupCreationFieldsPresentAndAllowed() {
          let expectedFields = ['name', 'description', 'purpose', 'theme', 'imageUrl', 'ownerId', 'memberUserIds', 'inviteCode', 'selfDestructTimerDays', 'selfDestructAt', 'createdAt', 'lastActivity'];
          return request.resource.data.keys().hasAll(expectedFields) && request.resource.data.keys().hasOnly(expectedFields);
      }


      // --- Group Access Rules ---

      allow read: if isAuthenticated() && isUserInMemberList(resource.data.memberUserIds, request.auth.uid);

      allow create: if isAuthenticated() &&
                       request.auth.uid == request.resource.data.ownerId &&
                       hasValidGroupCreationFields() &&
                       allGroupCreationFieldsPresentAndAllowed();

      allow update: if isAuthenticated() &&
                       // Condition for JOINING a group
                       (
                         groupIsActive() && // Check existing group is active
                         !isUserInMemberList(resource.data.memberUserIds, request.auth.uid) && // User is not already a member
                         request.resource.data.memberUserIds == resource.data.memberUserIds.concat([request.auth.uid]) && // Only adding self
                         request.resource.data.lastActivity == request.time &&
                         // Ensure ONLY memberUserIds and lastActivity are changed for joining
                         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['memberUserIds', 'lastActivity']) &&
                         // Ensure other essential fields are not modified from their original values
                         request.resource.data.name == resource.data.name &&
                         request.resource.data.description == resource.data.description &&
                         request.resource.data.ownerId == resource.data.ownerId &&
                         request.resource.data.inviteCode == resource.data.inviteCode &&
                         request.resource.data.selfDestructAt == resource.data.selfDestructAt &&
                         request.resource.data.createdAt == resource.data.createdAt &&
                         request.resource.data.purpose == resource.data.purpose &&
                         request.resource.data.theme == resource.data.theme &&
                         request.resource.data.imageUrl == resource.data.imageUrl &&
                         request.resource.data.selfDestructTimerDays == resource.data.selfDestructTimerDays
                       );
                       // Add other update scenarios here with `|| (...)` e.g. for owner updating group details

      allow delete: if false; // Group deletion handled by self-destruct timer (implicitly, e.g. via a backend function)
    }
  }
}

    